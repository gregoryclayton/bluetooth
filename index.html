<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bluetooth + Geolocation Logger</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; }
    #log { white-space: pre; background: #f5f5f5; padding: 0.5rem; height: 200px; overflow: auto; }
    #canvas { border: 1px solid #ccc; background: #fafafa; }
    button { margin: 0.25rem 0; }
  </style>
</head>
<body>
  <h1>Bluetooth + Geolocation Logger</h1>
  <p><strong>Important:</strong> This page must be served over HTTPS (or localhost) for both Geolocation and Web Bluetooth.</p>
  <p>
    <button id="initGeo">Get Initial Location</button>
    <button id="scanBt" disabled>Scan for Bluetooth Device</button>
  </p>
  <canvas id="canvas" width="500" height="300"></canvas>
  <h3>Log</h3>
  <div id="log"></div>

  <script>
    const logEl = document.getElementById('log');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const initGeoBtn = document.getElementById('initGeo');
    const scanBtn = document.getElementById('scanBt');

    let origin = null; // { lat, lon }
    const sightings = []; // { name, lat, lon, dx, dy, timestamp }

    function log(msg) {
      const line = `[${new Date().toLocaleTimeString()}] ${msg}\n`;
      logEl.textContent += line;
      logEl.scrollTop = logEl.scrollHeight;
      console.log(msg);
    }

    function setOrigin(pos) {
      origin = {
        lat: pos.coords.latitude,
        lon: pos.coords.longitude
      };
      log(`Origin set at lat=${origin.lat.toFixed(6)}, lon=${origin.lon.toFixed(6)}`);
      scanBtn.disabled = false;
      draw();
    }

    function toMetersOffset(lat1, lon1, lat2, lon2) {
      // Rough equirectangular approximation for small distances
      const R = 6371000; // meters
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const x = dLon * Math.cos((lat1 + lat2) * Math.PI / 360) * R;
      const y = dLat * R;
      return { x, y };
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // axes at center
      ctx.strokeStyle = '#ccc';
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 0);
      ctx.lineTo(canvas.width / 2, canvas.height);
      ctx.moveTo(0, canvas.height / 2);
      ctx.lineTo(canvas.width, canvas.height / 2);
      ctx.stroke();

      // origin
      ctx.fillStyle = 'red';
      ctx.beginPath();
      ctx.arc(canvas.width / 2, canvas.height / 2, 5, 0, 2 * Math.PI);
      ctx.fill();
      ctx.fillText('Origin', canvas.width / 2 + 8, canvas.height / 2 - 8);

      // points
      ctx.fillStyle = 'blue';
      const scale = 0.5; // pixels per meter (adjust as needed)
      for (const s of sightings) {
        const x = canvas.width / 2 + s.dx * scale;
        const y = canvas.height / 2 - s.dy * scale; // invert y for display
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillText(s.name, x + 6, y - 6);
      }
    }

    initGeoBtn.addEventListener('click', () => {
      if (!('geolocation' in navigator)) {
        log('Geolocation not supported');
        return;
      }
      navigator.geolocation.getCurrentPosition(
        setOrigin,
        (err) => log(`Geolocation error: ${err.message}`),
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
      );
    });

    scanBtn.addEventListener('click', async () => {
      if (!origin) {
        log('Set origin first.');
        return;
      }
      if (!navigator.bluetooth) {
        log('Web Bluetooth not supported in this browser.');
        return;
      }

      try {
        // You must specify filters or acceptAllDevices; many browsers restrict broad scans.
        const device = await navigator.bluetooth.requestDevice({
          // Example: match any device (less restrictive); may not be allowed in all browsers.
          acceptAllDevices: true,
          optionalServices: [] // Add service UUIDs if you need to connect/read
        });

        log(`User selected device: ${device.name || '(no name)'} [id=${device.id}]`);

        // Get position at selection time
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            const { latitude, longitude } = pos.coords;
            const { x, y } = toMetersOffset(origin.lat, origin.lon, latitude, longitude);
            const sighting = {
              name: device.name || '(no name)',
              lat: latitude,
              lon: longitude,
              dx: x,
              dy: y,
              timestamp: Date.now()
            };
            sightings.push(sighting);
            log(`Logged sighting: ${sighting.name} at dx=${x.toFixed(1)}m, dy=${y.toFixed(1)}m`);
            draw();
          },
          (err) => log(`Geolocation error on log: ${err.message}`),
          { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
        );
      } catch (err) {
        log(`Bluetooth request failed: ${err.message}`);
      }
    });
  </script>
</body>
</html>
