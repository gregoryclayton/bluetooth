<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bluetooth Sightings Path Mapper</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; }
    #log { white-space: pre; background: #f5f5f5; padding: 0.5rem; height: 200px; overflow: auto; }
    #canvas { border: 1px solid #ccc; background: #fafafa; }
    button { margin: 0.25rem 0; }
  </style>
</head>
<body>
  <h1>Bluetooth Sightings Path Mapper</h1>
  <p><strong>Requires HTTPS/localhost. Multi-device scanning needs Chrome with “Experimental Web Platform features” enabled.</strong></p>
  <p>
    <button id="initGeo">Set Origin (initial position)</button>
    <button id="scanBt" disabled>Start Scan (plot all devices)</button>
    <button id="stopScan" disabled>Stop Scan</button>
  </p>
  <canvas id="canvas" width="600" height="360"></canvas>
  <h3>Log</h3>
  <div id="log"></div>

  <script>
    const logEl = document.getElementById('log');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const initGeoBtn = document.getElementById('initGeo');
    const scanBtn = document.getElementById('scanBt');
    const stopBtn = document.getElementById('stopScan');

    let origin = null; // { lat, lon }
    const sightings = []; // [{ key, name, dx, dy, lat, lon, timestamp }]
    let activeScan = null;
    const lastSeenAt = new Map(); // key -> timestamp
    const MIN_INTERVAL_MS = 5000; // throttle repeated logs per device

    function log(msg) {
      const line = `[${new Date().toLocaleTimeString()}] ${msg}\n`;
      logEl.textContent += line;
      logEl.scrollTop = logEl.scrollHeight;
      console.log(msg);
    }

    function setOrigin(pos) {
      origin = { lat: pos.coords.latitude, lon: pos.coords.longitude };
      log(`Origin set at lat=${origin.lat.toFixed(6)}, lon=${origin.lon.toFixed(6)}`);
      scanBtn.disabled = false;
      draw();
    }

    function toMetersOffset(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const x = dLon * Math.cos((lat1 + lat2) * Math.PI / 360) * R;
      const y = dLat * R;
      return { x, y };
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // axes
      ctx.strokeStyle = '#ddd';
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 0); ctx.lineTo(canvas.width / 2, canvas.height);
      ctx.moveTo(0, canvas.height / 2); ctx.lineTo(canvas.width, canvas.height / 2);
      ctx.stroke();

      // origin
      ctx.fillStyle = 'red';
      ctx.beginPath();
      ctx.arc(canvas.width / 2, canvas.height / 2, 5, 0, 2 * Math.PI);
      ctx.fill();
      ctx.fillText('Origin', canvas.width / 2 + 8, canvas.height / 2 - 8);

      const scale = 0.5; // px per meter; adjust for density

      // path in time order
      const ordered = [...sightings].sort((a, b) => a.timestamp - b.timestamp);
      if (ordered.length > 1) {
        ctx.strokeStyle = '#888';
        ctx.beginPath();
        ordered.forEach((s, i) => {
          const x = canvas.width / 2 + s.dx * scale;
          const y = canvas.height / 2 - s.dy * scale;
          if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        });
        ctx.stroke();
      }

      // points
      ctx.fillStyle = 'blue';
      for (const s of ordered) {
        const x = canvas.width / 2 + s.dx * scale;
        const y = canvas.height / 2 - s.dy * scale;
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillText(s.name, x + 6, y - 6);
      }
    }

    function recordSighting(name, key) {
      if (!origin) {
        log('Origin not set; cannot log.');
        return;
      }
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const { latitude, longitude } = pos.coords;
          const { x, y } = toMetersOffset(origin.lat, origin.lon, latitude, longitude);
          const ts = Date.now();
          sightings.push({ key, name, dx: x, dy: y, lat: latitude, lon: longitude, timestamp: ts });
          log(`Plotted ${name} at dx=${x.toFixed(1)}m, dy=${y.toFixed(1)}m`);
          draw();
        },
        (err) => log(`Geolocation error: ${err.message}`),
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
      );
    }

    // Set origin
    initGeoBtn.addEventListener('click', () => {
      if (!navigator.geolocation) return log('Geolocation not supported.');
      navigator.geolocation.getCurrentPosition(
        setOrigin,
        (err) => log(`Geolocation error: ${err.message}`),
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
      );
    });

    // Start scan: plot every device seen (first seen, then throttled repeats)
    scanBtn.addEventListener('click', async () => {
      if (!origin) return log('Set origin first.');
      if (!navigator.bluetooth || !navigator.bluetooth.requestLEScan) {
        log('Scanning API not supported. Enable experimental flag or use a compatible Chrome build.');
        return;
      }
      try {
        activeScan = await navigator.bluetooth.requestLEScan({
          acceptAllAdvertisements: true,
          keepRepeatedDevices: true // allow repeats so we can trace movement
        });
        scanBtn.disabled = true;
        stopBtn.disabled = false;
        log('Scan started (experimental API)...');

        const onAdv = (event) => {
          const name = event.device.name || '(no name)';
          const key = event.device.id || `${name}-${event.manufacturerData?.size || 0}`;
          const now = Date.now();
          const last = lastSeenAt.get(key) || 0;
          if (now - last < MIN_INTERVAL_MS) return; // throttle per device
          lastSeenAt.set(key, now);
          recordSighting(name, key);
        };

        navigator.bluetooth.addEventListener('advertisementreceived', onAdv);

        // Keep reference to detach later
        activeScan._onAdv = onAdv;
      } catch (err) {
        log(`Scan failed: ${err.message}`);
      }
    });

    // Stop scan
    stopBtn.addEventListener('click', () => {
      if (activeScan && activeScan.active) activeScan.stop();
      if (activeScan && activeScan._onAdv) {
        navigator.bluetooth.removeEventListener('advertisementreceived', activeScan._onAdv);
      }
      activeScan = null;
      scanBtn.disabled = false;
      stopBtn.disabled = true;
      log('Scan stopped.');
    });
  </script>
</body>
</html>
