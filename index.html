<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Bluetooth + Geolocation Logger (Scan All)</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; }
    #log { white-space: pre; background: #f5f5f5; padding: 0.5rem; height: 220px; overflow: auto; }
    #canvas { border: 1px solid #ccc; background: #fafafa; }
    button { margin: 0.25rem 0; }
  </style>
</head>
<body>
  <h1>Bluetooth + Geolocation Logger</h1>
  <p><strong>Needs HTTPS/localhost. Scanning all devices requires Chrome with “Experimental Web Platform features” enabled.</strong></p>
  <p>
    <button id="initGeo">Get Initial Location</button>
    <button id="scanBt" disabled>Scan Bluetooth (discover all)</button>
    <button id="stopScan" disabled>Stop Scan</button>
    <button id="singleSelect">Single Device (chooser fallback)</button>
  </p>
  <canvas id="canvas" width="500" height="300"></canvas>
  <h3>Log</h3>
  <div id="log"></div>

  <script>
    const logEl = document.getElementById('log');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const initGeoBtn = document.getElementById('initGeo');
    const scanBtn = document.getElementById('scanBt');
    const stopBtn = document.getElementById('stopScan');
    const singleSelectBtn = document.getElementById('singleSelect');

    let origin = null; // { lat, lon }
    const sightings = []; // { key, name, lat, lon, dx, dy, timestamp }
    let activeScan = null;

    function log(msg) {
      const line = `[${new Date().toLocaleTimeString()}] ${msg}\n`;
      logEl.textContent += line;
      logEl.scrollTop = logEl.scrollHeight;
      console.log(msg);
    }

    function setOrigin(pos) {
      origin = {
        lat: pos.coords.latitude,
        lon: pos.coords.longitude
      };
      log(`Origin set at lat=${origin.lat.toFixed(6)}, lon=${origin.lon.toFixed(6)}`);
      scanBtn.disabled = false;
      singleSelectBtn.disabled = false;
      draw();
    }

    function toMetersOffset(lat1, lon1, lat2, lon2) {
      const R = 6371000; // meters
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const x = dLon * Math.cos((lat1 + lat2) * Math.PI / 360) * R;
      const y = dLat * R;
      return { x, y };
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = '#ccc';
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 0);
      ctx.lineTo(canvas.width / 2, canvas.height);
      ctx.moveTo(0, canvas.height / 2);
      ctx.lineTo(canvas.width, canvas.height / 2);
      ctx.stroke();

      ctx.fillStyle = 'red';
      ctx.beginPath();
      ctx.arc(canvas.width / 2, canvas.height / 2, 5, 0, 2 * Math.PI);
      ctx.fill();
      ctx.fillText('Origin', canvas.width / 2 + 8, canvas.height / 2 - 8);

      ctx.fillStyle = 'blue';
      const scale = 0.5; // pixels per meter; adjust to taste
      for (const s of sightings) {
        const x = canvas.width / 2 + s.dx * scale;
        const y = canvas.height / 2 - s.dy * scale; // invert y for display
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, 2 * Math.PI);
        ctx.fill();
        ctx.fillText(s.name, x + 6, y - 6);
      }
    }

    function recordSighting(name, key) {
      if (!origin) {
        log('Origin not set; cannot log location.');
        return;
      }
      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const { latitude, longitude } = pos.coords;
          const { x, y } = toMetersOffset(origin.lat, origin.lon, latitude, longitude);
          const sighting = {
            key,
            name,
            lat: latitude,
            lon: longitude,
            dx: x,
            dy: y,
            timestamp: Date.now()
          };
          sightings.push(sighting);
          log(`Logged ${name} at dx=${x.toFixed(1)}m, dy=${y.toFixed(1)}m`);
          draw();
        },
        (err) => log(`Geolocation error on log: ${err.message}`),
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
      );
    }

    initGeoBtn.addEventListener('click', () => {
      if (!('geolocation' in navigator)) {
        log('Geolocation not supported');
        return;
      }
      navigator.geolocation.getCurrentPosition(
        setOrigin,
        (err) => log(`Geolocation error: ${err.message}`),
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
      );
    });

    // Experimental scanning for all advertisements
    scanBtn.addEventListener('click', async () => {
      if (!origin) {
        log('Set origin first.');
        return;
      }
      if (!navigator.bluetooth || !navigator.bluetooth.requestLEScan) {
        log('Scanning API not supported; use Single Device fallback.');
        return;
      }
      try {
        // Requires user gesture + experimental flag in Chrome
        activeScan = await navigator.bluetooth.requestLEScan({
          acceptAllAdvertisements: true, // broad scan
          keepRepeatedDevices: false    // only first sighting per device
          // You can add filters like { services: ['battery_service'] } to narrow results
        });
        scanBtn.disabled = true;
        stopBtn.disabled = false;
        log('Scanning started (experimental API)...');

        navigator.bluetooth.addEventListener('advertisementreceived', (event) => {
          const name = event.device.name || '(no name)';
          const key = event.device.id || `${event.device.name}-${event.manufacturerData?.size || 0}`;
          // avoid duplicate logging if keepRepeatedDevices is true; otherwise, this is first sighting
          if (sightings.some(s => s.key === key)) return;
          recordSighting(name, key);
        });
      } catch (err) {
        log(`Scan failed: ${err.message}`);
      }
    });

    stopBtn.addEventListener('click', () => {
      if (activeScan && activeScan.active) {
        activeScan.stop();
        log('Scan stopped.');
      }
      activeScan = null;
      scanBtn.disabled = false;
      stopBtn.disabled = true;
    });

    // Fallback: classic chooser (one device per click)
    singleSelectBtn.addEventListener('click', async () => {
      if (!origin) {
        log('Set origin first.');
        return;
      }
      if (!navigator.bluetooth) {
        log('Web Bluetooth not supported in this browser.');
        return;
      }
      try {
        const device = await navigator.bluetooth.requestDevice({
          acceptAllDevices: true,
          optionalServices: []
        });
        const name = device.name || '(no name)';
        recordSighting(name, device.id);
      } catch (err) {
        log(`Bluetooth request failed: ${err.message}`);
      }
    });
  </script>
</body>
</html>
